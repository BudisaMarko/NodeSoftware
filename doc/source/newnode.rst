.. _newnode:

Step by step guide to a new VAMDC node
======================================

Let's have a look at the structural diagram from the :ref:`intro` once more:

.. image:: nodelayout.png
   :width: 700 px
   :alt: Structural layout of a VAMDC node

If you have followed the instructions of the page on :ref:`prereq`, you 
are done with the yellow box in the figure. This page will tell you 
first how to configure and write the few code bits that your node needs 
before running (blue box), and then how to deploy the node and make it run 
as shown in the violet box.

It goes like this:

* Get the Nodesoftware and make a copy of the example node.
* Auto-create a new settings file and put your database connection there.
* Either
    * Write your data model and let Django create the database from it. Then use the import tool to put your data there.
    * Let Django write the model from an existing database that you already have.
* Assign names from the VAMDC dictionary to your data to make them globally understandable.
* Start/deploy your node and test it.


But let's take it step by step:

The main directory of your node
---------------------------------

Let's give the directory which holds your copy of :ref:`source` (it is 
called NodeSoftware and exists whereever you ran the *git clone* 
command, unless you moved it elsewhere and/or renamed it, which is 
absolutely no problem) a name and call it *$VAMDCROOT*. Let's also assume
the name of the dataset is *YourDBname*.

Inside $VAMDCROOT you find several subdirectories. For setting up a new 
node, you only need to care about the one called *nodes/*. The very 
first thing to do, is to make a copy of the ExampleNode::

    $ git clone git://github.com/VAMDC/NodeSoftware.git
    $ export VAMDCROOT=`pwd`/NodeSoftware/
    $ # (the last line is for Bash-like shells, for C-Shell use *setenv* instead of *export*
    $ cd $VAMDCROOT/nodes/
    $ cp -a ExampleNode YourDBname
    $ cd YourDBname/
 
Inside your node directory
---------------------------------

The first thing to do inside your node directory is to run::

    $ ./manage.py

This will generate a new file *settings.py* for you. This file is where 
you override the default settings which reside in *settings_default.py* (which you should not edit!). 
There are two configurations items that you need to fill

* The information on how to connect to your database.
* A name and email address for the node administrator(s).

You can leave the default values for now, if you do not yet know what to 
fill in.

There are only three more files that you will need to care about:

* *node/models.py* is where you put the data model,
* *node/dictionaries.py* is where you put the dictionaries and
* *node/queryfunc.py* is where you write the query function,

all of which will be explained in detail in the following.

The data model and the database
---------------------------------

By *data model* we mean the piece of Python code that tells Django the 
layout of the database, including the relations between the tables. By 
*database* we mean the actual relational database that is to hold the 
data. See :ref:`concepts` for some more lines on this.

There are two basic scenarios to come up with these two ingredients. 
Either the data are already in a relational database, or you want to 
create one.

Case 1: Existing database
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to deploy the VAMDC node software on top of an existing 
relational database, the *data model* for Django can be automatically 
generated by running::

    $ ./manage.py inspectdb > node/models.py

This will look into the database that you told Django about in *settings.py* above 
and create a Python class for each table in the database and attributes 
for these that correspond to the table columns. An example may look like 
this::

    class Species(models.Model):
        id = models.IntegerField(primary_key=True)
        name = models.CharField(max_length=30)
        ion = models.IntegerField()
        mass = models.DecimalField(max_digits=7, decimal_places=2)
        massno = models.IntegerField()
        class Meta:
            db_table = u'species'

There is one important thing to do with these model definitions, apart 
from checking that the columns were detected correctly: The columns that 
act as a pointer to another table need to be replaced by *ForeignKeys*, 
thereby telling the framework how the tables relate to each other. This 
is best illustrated in an example. Suppose you have a second model, in 
addition to the one above, that was auto-detected as follows::

    class States(models.Model):
        id = models.IntegerField(primary_key=True)
        species = models.IntegerField()
        energy = models.DecimalField(max_digits=17, decimal_places=4)
        ...

Now suppose you know that the field called *species* is acutally a 
reference to the species-table. You would then change the class *States* 
as such::

    class States(models.Model):
        id = models.IntegerField(primary_key=True)
        species = models.ForeignKey(Species)
        energy = models.DecimalField(max_digits=17, decimal_places=4)
        ...

.. note:: 
    You will probably have to re-order the classes inside the file 
    *models.py*. The class that is referred to needs to be defined before 
    the one that refers to it.

Once you have finished your model, you should test it. Continuing the 
example above you could do::

    $ ./manage.py shell
    >>> from node.models import *
    >>> allspecies = Species.objects.all()
    >>> allspecies.count()
    XX # the number of species is returned
    >>> somestates = States.objects.filter(species__name='He')
    >>> for state in somestates: print state.energy


Case 2: Create a new database
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this case we assume that the data are in ascii tables of arbitrary 
layout. The steps now are as follows:

#. Write the data model
#. Create an empty database with corresponding user and password
#. Tell the node software where to find this database.
#. Let the node software create the tables
#. Use the import tool to fill the database with the data.

First of all, you need to think about how the data should be structured. 
Data conversion (units, structure etc) can and should be done while 
importing the data since this saves work and execution time later. Since 
the data will need to be represented in the common XSAMS format, it is 
recommended to adopt a layout with separate tables for

* Species
* States
* Processes
* References

Deviating data models are certainly possible, but will involve some more 
work on the query function (see below). In any case, do not so much 
think about how your data is structured now, but how you want it to be 
structured in the database, when writing the models.

Writing your data models is best learned from example. Have a look at 
the example from Case 1 above and at file *nodes/vald/node/models.py* 
inside the NodeSoftware to see how the model for VALD looks like. Keep 
in mind the following points

* As mentioned, a *class* in the model becomes a *table* in the 
  database.
* Each class should have a member with *primary_key=True*. If 
  not, one called *id* will be implicitly created for you.
* How you name your classes and fields is up to you. Sensible names will make it easier to write the dictionaries below.
* Use the appropriate field type for each bit of data, e.g. BooleanField, 
  CharField, PositiveSmallIntegerField, FloatField. There is a 
  DecimalField that allows you to specify arbitrary precision which will 
  also be used in later ascii-representations.
* Use *ForeignKey()* to another class's primary key to connect your tables.
* The full list of possible fields can be found at http://docs.djangoproject.com/en/1.2/ref/models/fields/.
* If you know that a field will be empty sometimes, add *null=True* to the field definition inside the brackets ().
* For fields that are frequent selection criteria (like wavelength for a transition database), you can add *db_index=True* to the field to speed up searches along this column (at the expense of some disk space and computation time at database creation).

Once you have a first draft of your data model, you test it by running::

    $ ./manage.py sqlall

This will (if you have no error in the models) print the SQL statements 
that Django will use to create the database, using the file or 
connection information in *settings.py*. If you do not know SQL, you can 
ignore the output and move straight on to creating the database::

    $ ./manage.py syncdb

Now you have a fresh empty database. You can test it with the same 
commands as mentioned at the end of Case 1 above, replacing "Species" 
and "States" by you own model names.

.. note::
    There is no harm in deleting the database and re-creating it
    after improving your models. After all the database is still
    empty at this stage and *syncdb* will always create it for
    you from the models, even if you change your database
    engine in *settings.py*.

How you fill your database with information from ascii-files is 
explained in the next chapter: :ref:`importing`. You can do this now and 
return here later, or continue with the steps below.



The dictionaries
----------------------------------

Now that we have a database with data in it and the data model in place, 
we need to define how the data relates to the VAMDC *dictionary*. If you 
have not done so yet, please read :ref:`conceptdict` before continuing.

What needs to be put into the file *node/dictionaries.py* is the 
definition of two variables that map the individual fields of the 
data model to the names from the dictionary, like this::

    RETURNABLES={\
    'SourceID':'Source.id',
    'SourceCategory':'journal', # using a constant string works
    'AtomStateEnergy':'AtomState.energy', 
    'RadTransWavelengthExperimentalValue':'RadTran.vacwave',
    }
    
    RESTRICTABLES = {\
    'AtomSymbol':'species__name',
    'AtomStateEnergy':'upstate__energy',
    'RadTransWavelengthExperimentalValue':'vacwave',
    }



The query routine
-----------------------------------

This file must implement a function called setupResults() which 
takes the parsed SQL from the query parser. setupResults() must pass 
the restrictions on to one or several of your models (depending on 
the database strcture) and also fetch the corresponding items from 
other models that are needed in the return data. setupResults() must 
return a DICTIONARY that has as keys some of the following: Sources 
AtomStates MoleStates CollTrans RadTrans Methods; with the 
corresponding QuerySets as the values for these keys. This 
dictionary will be handed into the generator an allow it to fill the 
XML schema.

Below is an example, inspired by VALD that has a data model like 
this:

* One for the Sources/References
* One for the Species
* One for the States (points to Species once, and to several 
  references)
* One for Transitions (points twice to States (upper, lower) and to 
  several Sources)

In this layout, all restrictions in the query can be passed to
the Transitions model (using the pointers between models to
restrict eg. Transition.species.ionization) which facilitates
things.

Now we can code two helper functions that get the corresponding
Sources and States to a selection of Transitions:




Deploying the node
------------------------------
