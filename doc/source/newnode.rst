.. _newnode:

Step by step guide to a new VAMDC node
======================================

Let's have a look at the structural diagram from the :ref:`intro` once more:

.. image:: nodelayout.png
   :width: 700 px
   :alt: Structural layout of a VAMDC node

If you have followed the instructions of the page on :ref:`prereq`, you 
are done with the yellow box in the figure. This page will tell you 
first how to configure and write the few code bits that your node needs 
before running (blue box), and then how to deply the node to make it run 
as shown in the violet box.


The main directory of your node
---------------------------------

Let's give the directory which holds your copy of :ref:`source` (it is 
called NodeSoftware and exists whereever you ran the *git clone* 
command, unless you moved it elsewhere and/or renamed it, which is 
absolutely no problem) a name and call it *$VAMDCROOT*. Let's also assume
the name of the dataset is *YourDBname*.

Inside $VAMDCROOT you find several subdirectories. For setting up a new 
node, you only need to care about the one called *nodes/*. The very 
first thing to do, is to make a copy of the ExampleNode::

    $ git clone https://ivh@github.com/VAMDC/NodeSoftware.git
    $ export $VAMDCROOT=`pwd`/NodeSoftware/
    $ # (the last line is for Bash-like shells, for C-Shell use *setenv* instead of *export*
    $ cd $VAMDCROOT/nodes/
    $ cp -a ExampleNode YourDBname
    $ cd YourDBname/
 
Inside your node directory
---------------------------------

The first thing to do inside your node directory is to run::

    $ ./manage.py

This will generate a new file *settings.py* for you. This file is where 
you override the default settings which reside in *settings_default.py*. 
There are three configurations items that you need to fill

* The information on how to connect to your database.
* The URL at which the node will be accessible later
* A name and email address for the node administrator(s).

You can leave the default values for now, if you do not yet know what to 
fill in.

There are only three more files that you will need to care about:

* *node/models.py* is where you put the data model,
* *node/dictionaries.py* is where you put the dictionaries and
* *node/queryfunc.py* is where you write the query function,

all of which will be explained in detail in the following.

The data model and the database
---------------------------------

By *data model* we mean the piece of Python code that tells Django the 
layout of the database, including the relations between the tables. By 
*database* we mean the actual relational database that is to hold the 
data.

There are two basic scenarios to come up with these two ingredients. 
Either the data are already in a relational database, or you want to 
create one.

Case 1: Create a new database
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Case 2: Existing database
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to deploy the VAMDC node software on top of an existing 
relational database, the *data model* for Django can be automatically 
generated by running::

    $ ./manage.py inspectdb > node/models.py

This will look into the database that you set up in *settings.py* above 
and create a Python class for each table in the database and 
attributes for these that correspond to the table columns. An example may look like this::

    class Species(models.Model):
        id = models.IntegerField(primary_key=True)
        name = models.CharField(max_length=30)
        ion = models.IntegerField()
        mass = models.DecimalField(max_digits=7, decimal_places=2)
        massno = models.IntegerField()
        class Meta:
            db_table = u'species'

There is one important thing to do with these model definitions, apart 
from checking that the columns were detected correctly: The columns that 
act as a pointer to another table need to be replaced by *ForeignKeys*, 
thereby telling the framework how the tables relate to each other. This 
is best illustrated in an example. Suppose you have a second model, in 
addition to the one above, that was auto-detected as follows::

    class States(models.Model):
        id = models.IntegerField(primary_key=True)
        species = models.IntegerField()
        energy = models.DecimalField(max_digits=17, decimal_places=4)
        ...

Now suppose you know that the field called *species* is acutally a 
reference to the species-table. You would then change the class *States* 
as such::

    class States(models.Model):
        id = models.IntegerField(primary_key=True)
        species = models.ForeignKey(Species)
        energy = models.DecimalField(max_digits=17, decimal_places=4)
        ...

.. note:: 
    You will probably have to re-order the classes inside the file 
    *models.py*. The class that is referred to needs to be defined before 
    the one that refers to it.

Once you have finished your model, you should test it. Continuing the 
example above you could do::

    $ ./manage.py shell
    >>> from node.models import *
    >>> allspecies = Species.objects.all()
    >>> allspecies.count()
    XX # the number of species is returned
    >>> somestates = States.objects.filter(species__name='He')
    >>> for state in somestates: print state.energy




The dictionaries
----------------------------------

Now that we have a database with data in it and the data model in place, 
we need to define how the data relates to the VAMDC *dictionary*. If you 
have not done so yet, please read :ref:`conceptdict` before continuing.

What needs to be put into the file *node/dictionaries.py* is the 
definition of two variables that map the individual fields of the 
data model to the names from the dictionary, like this::

    RETURNABLES={\
    'SourceID':'Source.id',
    'SourceCategory':'journal', # using a constant string works
    'AtomStateEnergy':'AtomState.energy', 
    'RadTransWavelengthExperimentalValue':'RadTran.vacwave',
    }
    
    RESTRICTABLES = {\
    'AtomSymbol':'species__name',
    'AtomStateEnergy':'upstate__energy',
    'RadTransWavelengthExperimentalValue':'vacwave',
    }



The query routine
-----------------------------------

This file must implement a function called setupResults() which 
takes the parsed SQL from the query parser. setupResults() must pass 
the restrictions on to one or several of your models (depending on 
the database strcture) and also fetch the corresponding items from 
other models that are needed in the return data. setupResults() must 
return a DICTIONARY that has as keys some of the following: Sources 
AtomStates MoleStates CollTrans RadTrans Methods; with the 
corresponding QuerySets as the values for these keys. This 
dictionary will be handed into the generator an allow it to fill the 
XML schema.

Below is an example, inspired by VALD that has a data model like 
this:

* One for the Sources/References
* One for the Species
* One for the States (points to Species once, and to several 
  references)
* One for Transitions (points twice to States (upper, lower) and to 
  several Sources)

In this layout, all restrictions in the query can be passed to
the Transitions model (using the pointers between models to
restrict eg. Transition.species.ionization) which facilitates
things.

Now we can code two helper functions that get the corresponding
Sources and States to a selection of Transitions:




Deploying the node
------------------------------
